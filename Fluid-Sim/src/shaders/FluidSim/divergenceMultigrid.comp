//calculate divergence for multigrid

#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#ifndef FORMAT
    #define FORMAT r16f
#endif

uniform layout (binding = 0) sampler3D velocity;
uniform layout(FORMAT, binding = 0) writeonly restrict image3D divergence;

void main() 
{
    ivec3 texelPos = ivec3(gl_GlobalInvocationID);
    ivec3 texSize = imageSize(divergence);
    if(texelPos.x < texSize.x 
    && texelPos.y < texSize.y 
    && texelPos.z < texSize.z
    )
    {
        //divergence is needed at cell corners, so sample the 8 cells around each corner and interpoalte their values to the "center of edges" to
        //calculate the divergence

        vec3 cell_xnext_ynext_znext = texelFetchOffset(velocity, texelPos, 0, ivec3( 0, 0, 0)).xyz;
        vec3 cell_xnext_ynext_zprev = texelFetchOffset(velocity, texelPos, 0, ivec3( 0, 0,-1)).xyz;
        vec3 cell_xnext_yprev_znext = texelFetchOffset(velocity, texelPos, 0, ivec3( 0,-1, 0)).xyz;
        vec3 cell_xnext_yprev_zprev = texelFetchOffset(velocity, texelPos, 0, ivec3( 0,-1,-1)).xyz;
        vec3 cell_xprev_ynext_znext = texelFetchOffset(velocity, texelPos, 0, ivec3(-1, 0, 0)).xyz;
        vec3 cell_xprev_ynext_zprev = texelFetchOffset(velocity, texelPos, 0, ivec3(-1, 0,-1)).xyz;
        vec3 cell_xprev_yprev_znext = texelFetchOffset(velocity, texelPos, 0, ivec3(-1,-1, 0)).xyz;
        vec3 cell_xprev_yprev_zprev = texelFetchOffset(velocity, texelPos, 0, ivec3(-1,-1,-1)).xyz;

        //force outside velocities to 0
        if(texelPos.x == 0)
        {
            cell_xprev_ynext_znext = vec3(0.0);
            cell_xprev_ynext_zprev = vec3(0.0);
            cell_xprev_yprev_znext = vec3(0.0);
            cell_xprev_yprev_zprev = vec3(0.0);
        }
        else if(texelPos.x == texSize.x-1)
        {
            cell_xnext_ynext_znext = vec3(0.0);
            cell_xnext_ynext_zprev = vec3(0.0);
            cell_xnext_yprev_znext = vec3(0.0);
            cell_xnext_yprev_zprev = vec3(0.0);
        }
        if(texelPos.y == 0)
        {
            cell_xnext_yprev_znext = vec3(0.0);
            cell_xnext_yprev_zprev = vec3(0.0);
            cell_xprev_yprev_znext = vec3(0.0);
            cell_xprev_yprev_zprev = vec3(0.0);
        }
        else if(texelPos.y == texSize.y-1)
        {
            cell_xnext_ynext_znext = vec3(0.0);
            cell_xnext_ynext_zprev = vec3(0.0);
            cell_xprev_ynext_znext = vec3(0.0);
            cell_xprev_ynext_zprev = vec3(0.0);
        }
        if(texelPos.z == 0)
        {
            cell_xnext_ynext_zprev = vec3(0.0);
            cell_xnext_yprev_zprev = vec3(0.0);
            cell_xprev_ynext_zprev = vec3(0.0);
            cell_xprev_yprev_zprev = vec3(0.0);
        }
        else if(texelPos.z == texSize.z-1)
        {
            cell_xnext_ynext_znext = vec3(0.0);
            cell_xnext_yprev_znext = vec3(0.0);
            cell_xprev_ynext_znext = vec3(0.0);
            cell_xprev_yprev_znext = vec3(0.0);
        }

        //axis - previous/next
        vec3 xprev = (cell_xprev_ynext_znext + cell_xprev_ynext_zprev + cell_xprev_yprev_znext + cell_xprev_yprev_zprev) / 4.0;
        vec3 xnext = (cell_xnext_ynext_znext + cell_xnext_ynext_zprev + cell_xnext_yprev_znext + cell_xnext_yprev_zprev) / 4.0;
        vec3 yprev = (cell_xnext_yprev_znext + cell_xnext_yprev_zprev + cell_xprev_yprev_znext + cell_xprev_yprev_zprev) / 4.0;
        vec3 ynext = (cell_xnext_ynext_znext + cell_xnext_ynext_zprev + cell_xprev_ynext_znext + cell_xprev_ynext_zprev) / 4.0;
        vec3 zprev = (cell_xnext_ynext_zprev + cell_xnext_yprev_zprev + cell_xprev_ynext_zprev + cell_xprev_yprev_zprev) / 4.0;
        vec3 znext = (cell_xnext_ynext_znext + cell_xnext_yprev_znext + cell_xprev_ynext_znext + cell_xprev_yprev_znext) / 4.0;

        //just so it follows formula, could of course just do partialXX = (next - prev)*(texSize.x-1) instead of "double div"
        const float deltaX = 1.0/(texSize.x-1.0);
        const float deltaY = 1.0/(texSize.y-1.0);
        const float deltaZ = 1.0/(texSize.z-1.0);

        const float partialXX = (xnext.x - xprev.x)/(deltaX);
        const float partialYY = (ynext.y - yprev.y)/(deltaY);
        const float partialZZ = (znext.z - zprev.z)/(deltaZ);

        const float div = (partialXX + partialYY + partialZZ);

        // i have NO clue why this is necessary, but just imageStore(...,vec4(div)) does not work, *need* ifs and (partialXX+...)
        if(texelPos.x % 2 == 0)
        {
            // imageStore(divergence, texelPos, vec4(div));
            imageStore(divergence, texelPos, vec4((partialXX + partialYY + partialZZ)));
            return;
        }
        else
        {
            // imageStore(divergence, texelPos, vec4(div));
            imageStore(divergence, texelPos, vec4((partialXX + partialYY + partialZZ)));
            return;
        }

        // imageStore(divergence, texelPos, vec4(div));
    }
}
