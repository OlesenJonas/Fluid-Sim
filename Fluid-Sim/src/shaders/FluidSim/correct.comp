//correct current guess based on error on lower level

#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#ifndef FORMAT
    #define FORMAT r16f
#endif

uniform layout (binding = 0) sampler3D currentGuessTex;
uniform layout (binding = 1) sampler3D e2h;

uniform layout(FORMAT, binding = 0) writeonly restrict image3D correctedGuessTex;

void main() 
{
    ivec3 texelPos = ivec3(gl_GlobalInvocationID);
    ivec3 textureSize = imageSize(correctedGuessTex);

    if(texelPos.x < textureSize.x 
    && texelPos.y < textureSize.y
    && texelPos.z < textureSize.z
    )
    {
        bool xeven = texelPos.x % 2 == 0;
        bool yeven = texelPos.y % 2 == 0;
        bool zeven = texelPos.z % 2 == 0;

        //better way with less branching? seems terrible
        //use local storage to share loads at least?

        float error = 0.0;
        if(xeven)
        {
            if(yeven)
            {
                if(zeven)
                {
                    error = texelFetch(e2h, texelPos / 2, 0).x;
                }
                else //z uneven
                {
                    error = 0.5*(
                        texelFetchOffset(e2h, (texelPos-ivec3(0,0,1)) / 2, 0, ivec3( 0, 0, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(0,0,1)) / 2, 0, ivec3( 0, 0, 1)).x
                        );
                }
            }
            else //y uneven
            {
                if(zeven)
                {
                    error = 0.5*(
                        texelFetchOffset(e2h, (texelPos-ivec3(0,1,0)) / 2, 0, ivec3( 0, 0, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(0,1,0)) / 2, 0, ivec3( 0, 1, 0)).x
                        );
                }
                else //z uneven
                {
                    error = 0.25*(
                        texelFetchOffset(e2h, (texelPos-ivec3(0,1,1)) / 2, 0, ivec3( 0, 0, 1)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(0,1,1)) / 2, 0, ivec3( 0, 0, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(0,1,1)) / 2, 0, ivec3( 0, 1, 1)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(0,1,1)) / 2, 0, ivec3( 0, 1, 0)).x
                        );
                }

            }
        }
        else //x is uneven
        {
            if(yeven)
            {
                if(zeven)
                {
                    error = 0.5*(
                        texelFetchOffset(e2h, (texelPos-ivec3(1,0,0)) / 2, 0, ivec3( 0, 0, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,0,0)) / 2, 0, ivec3( 1, 0, 0)).x
                        );
                }
                else //z uneven
                {
                    error = 0.25*(
                        texelFetchOffset(e2h, (texelPos-ivec3(1,0,1)) / 2, 0, ivec3( 0, 0, 1)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,0,1)) / 2, 0, ivec3( 0, 0, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,0,1)) / 2, 0, ivec3( 1, 0, 1)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,0,1)) / 2, 0, ivec3( 1, 0, 0)).x
                        );
                }
            }
            else //y uneven
            {
                if(zeven)
                {
                    error = 0.25*(
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,0)) / 2, 0, ivec3( 0, 1, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,0)) / 2, 0, ivec3( 0, 0, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,0)) / 2, 0, ivec3( 1, 1, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,0)) / 2, 0, ivec3( 1, 0, 0)).x
                        );
                }
                else //z uneven
                {
                    error = 0.125*(
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,1)) / 2, 0, ivec3( 0, 0, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,1)) / 2, 0, ivec3( 0, 0, 1)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,1)) / 2, 0, ivec3( 0, 1, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,1)) / 2, 0, ivec3( 0, 1, 1)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,1)) / 2, 0, ivec3( 1, 0, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,1)) / 2, 0, ivec3( 1, 0, 1)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,1)) / 2, 0, ivec3( 1, 1, 0)).x +
                        texelFetchOffset(e2h, (texelPos-ivec3(1,1,1)) / 2, 0, ivec3( 1, 1, 1)).x 
                        );
                }

            }

        }

        float currentGuess = texelFetch(currentGuessTex, texelPos, 0).x;

        imageStore(correctedGuessTex, texelPos, vec4(currentGuess + error));
    }
}
